// Generated by CoffeeScript 2.5.1
(function() {
  var CLUI, Spinner, c, checkFileExists, failCollection, fs, git, gitmodulesHandler, handleLevel, log, olog, ostr, pathHandler, print, printError, printFailCollection, pullLevel, pullcommandmodule;

  pullcommandmodule = {
    name: "pullcommandmodule"
  };

  //region modulesFromTheEnvironment
  //region node_modules
  gitmodulesHandler = require("gitmodules-file-handler");

  fs = require("fs");

  c = require("chalk");

  CLUI = require("clui");

  Spinner = CLUI.Spinner;

  //endregion

  //region localModules
  git = null;

  pathHandler = null;

  //endregion
  //endregion

  //region printLogFunctions
  //#############################################################################
  log = function(arg) {
    if (allModules.debugmodule.modulesToDebug["pullcommandmodule"] != null) {
      console.log("[pullcommandmodule]: " + arg);
    }
  };

  olog = function(arg) {
    return log(ostr(arg));
  };

  ostr = function(obj) {
    return JSON.stringify(obj, null, 4);
  };

  print = function(arg) {
    return console.log(arg);
  };

  printError = function(arg) {
    return console.log(c.red(arg));
  };

  //endregion
  //#############################################################################
  pullcommandmodule.initialize = function() {
    log("pullcommandmodule.initialize");
    pathHandler = allModules.pathhandlermodule;
    git = allModules.gitmodule;
  };

  failCollection = [];

  //region internalFunctions
  printFailCollection = function() {
    var fail, i, len;
    log("printFailCollection");
    if (failCollection.length === 0) {
      print("Success! nothing has failed :-)");
      return;
    }
    for (i = 0, len = failCollection.length; i < len; i++) {
      fail = failCollection[i];
      print(" - - - ");
      printError("Fail on: " + fail.path);
      printError("\n> " + fail.err);
    }
  };

  pullLevel = async function(path) {
    var err, failObject;
    log("pullLevel");
    try {
      await git.pull(path);
      await git.checkoutMaster(path);
    } catch (error) {
      err = error;
      failObject = {
        path: path,
        err: err
      };
      failCollection.push(failObject);
    }
  };

  handleLevel = async function(path) {
    var exists, levelModules, modules, modulesFile, name, nextLevelPaths, promises;
    log("handleLevel");
    await pullLevel(path);
    modulesFile = pathHandler.resolve(path, ".gitmodules");
    exists = (await checkFileExists(modulesFile));
    if (!exists) {
      return;
    }
    log("moduleFile existed: " + modulesFile);
    levelModules = (await gitmodulesHandler.readNewGitmodulesFile(modulesFile));
    modules = levelModules.getAllModules();
    nextLevelPaths = (function() {
      var results;
      results = [];
      for (name in modules) {
        results.push(pathHandler.resolve(path, name));
      }
      return results;
    })();
    promises = nextLevelPaths.map(handleLevel);
    await Promise.all(promises);
  };

  checkFileExists = async function(path) {
    var err, stat;
    log("checkFileExists");
    try {
      stat = (await fs.promises.stat(path));
    } catch (error) {
      err = error;
      return false;
    }
    return stat.isFile();
  };

  //endregion

  //region exposedFunctions
  pullcommandmodule.execute = async function() {
    var basePath, status, statusMessage;
    log("pullcommandmodule.execute");
    basePath = pathHandler.basePath;
    statusMessage = "pulling recursively...";
    status = new Spinner(statusMessage);
    status.start();
    try {
      await handleLevel(basePath);
    } finally {
      status.stop();
      printFailCollection();
    }
  };

  //endregion
  module.exports = pullcommandmodule;

}).call(this);
